#pragma once

#include "VulkanCommon.hshad"

#define UNLIT 0
#define BLINN 1
#define PHONG 2
#define TOON 3

struct Light
{
	vec4 position;
	vec4 direction;
	vec4 color;
	mat4 lightView;
	mat4 lightProjection;
};

const mat4 biasMat = mat4( 
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.5, 0.5, 0.0, 1.0 
);

float LinearizeDepth(float depth)
{
	float n = .1;
	float f = 1000.0;
	float z = depth * 2.0 - 1.0;
	return ((2.0 * n * f) / (f + n - z * (f - n))) / f;
}

float shadowProjection(vec4 lightSpacePosition)
{
	float shadow = 1;
//	vec4 shadowCoords = lightSpacePosition / lightSpacePosition.w;
//	shadowCoords.st = shadowCoords.st *.5 + .5;
//
//	float depthValue = texture(shadowMapTexture, shadowCoords.st).r;
//	float shadowProjValue = shadowCoords.z;
//
//	if (shadowCoords.z > -1.0 && shadowCoords.z < 1.0)
//	{
//		if(depthValue < shadowProjValue)
//		{
//			shadow = .25f;
//		}
//	}
	return shadow;
}

vec3 PhongModel(Light lights, vec3 viewPosition, vec3 position, vec3 normal, vec4 albedo)
{
	const float specular_power = 128.0;
	vec3 L = normalize(lights.position.xyz - position);//normalize(lights.direction.xyz);
	vec3 N = normalize(normal);
	vec3 V = normalize(viewPosition.xyz - position);

	// Calculate R locally
	vec3 R = reflect(-L, N);

	float difference = max(dot(N, L), 0.0);
	vec3 diffuse = difference * albedo.rgb;
    
	float specularValue = pow(max(dot(R, V), 0.0), specular_power);
	vec3 specular = lights.color.rgb * specularValue;

	//vec4 shadowPos = lights.lightProjection * lights.lightView * fragPos;
	//shadowPos = VulkanProjectionModification(shadowPos);
	//shadowPos = biasMat * shadowPos;
	//float shadow = shadowProjection(shadowPos);

	// Write final color to the framebuffer
	return diffuse + specular;
}

vec3 BlinnModel(Light lights, vec3 viewPosition, vec3 position, vec3 normal, vec4 albedo)
{
	const float specular_power = 128.0;
	// Normalize the incoming N, L and V vectors
    vec3 N = normalize(normal);
    vec3 L = normalize(lights.position.xyz - position);
    vec3 V = normalize(viewPosition.xyz - position);
    vec3 H = normalize(L + V);


	float difference = max(dot(N, L), 0.0);
	vec3 diffuse = difference * albedo.rgb;

	float specularValue = pow(max(dot(N, H), 0.0), specular_power);
    vec3 specular = lights.color.rgb * specularValue;

    // Write final color to the framebuffer
    return diffuse + specular;
}

vec3 ToonShadingModel(Light lights, vec3 position, vec3 normal, vec4 albedo)
{
	vec3 L = normalize(lights.position.xyz - position);
	vec3 N = normalize(normal);

	float intensity = clamp(dot(L, N), 0, 1);

	vec3 color = vec3(0);
	if(intensity > 0.95f)
	{
		color = albedo.rgb;
	}
	else if(intensity > 0.5f)
	{
		color = vec3(.7, .7, .7) * albedo.rgb;
	}
	else if(intensity > 0.05f)
	{
		color = vec3(.35, .35, .35) * albedo.rgb;
	}
	else
	{
		color = vec3(.1, .1, .1) * albedo.rgb;
	}

	return color;
}

